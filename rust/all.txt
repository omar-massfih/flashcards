What is Cargo in the Rust ecosystem?	The included dependency manager and build tool.
What does Cargo make easier?	Adding, compiling, and managing dependencies consistently.
What is rustfmt used for?	Automatic formatting to keep a consistent coding style.
Name three example domains where Rust is used in production.	Command line tools; web services; embedded devices.
What is rustup?	A command-line tool for managing Rust versions and associated tools.
Besides the compiler, what system tool is needed to produce a final executable?	A linker.
How do you update Rust installed via rustup?	Run `rustup update`.
How do you uninstall Rust and rustup?	Run `rustup self uninstall`.
How do you open the locally installed Rust documentation?	Run `rustup doc`.
After caching dependencies, how do you run Cargo commands without network access?	Use the `--offline` flag.
What file extension do Rust source files use?	`.rs`
What is the convention for multi-word Rust filenames?	Use underscores (e.g., `hello_world.rs`).
What is special about the `main` function in an executable Rust program?	It is the first code that runs.
In `fn main() {}`, what does `fn` declare?	A function.
How are function bodies written in Rust?	Inside curly braces `{}` (required for function bodies).
What does `println!` do in the Hello World example?	Prints the provided text to the screen/terminal.
What does the `!` in `println!` indicate?	It’s a macro invocation, not a normal function call.
What does a semicolon `;` typically indicate at the end of a line in Rust?	The expression/statement is finished.
How do you compile `main.rs` from the command line?	Run `rustc main.rs`.
After successful compilation with `rustc`, what do you get to run?	A binary executable.
How do you run the compiled executable on Linux/macOS?	`./main`
How do you run the compiled executable on Windows?	`.\\main`
What does it mean that Rust is ahead-of-time compiled?	You can compile to an executable that can run without Rust installed on the target machine.
Why use Cargo instead of `rustc` directly as projects grow?	To manage options/dependencies and make sharing/building easier.
What is Cargo?	Rust’s build system and package manager.
What kinds of tasks does Cargo handle for you?	Building your code, downloading dependencies, and building those dependencies.
Why do most Rust projects use Cargo?	It automates common project tasks and makes managing dependencies easier.
How can you check whether Cargo is installed?	Run `cargo --version`.
What does `cargo new <name>` do?	Creates a new project directory with a starter Rust program and Cargo config.
What two top-level items does Cargo generate in a new binary project (besides the `src` dir)?	`Cargo.toml` and a `src/` directory (with `main.rs` inside `src/`).
Where does Cargo expect Rust source files to live?	Inside the `src/` directory.
What is the purpose of the top-level project directory in a Cargo project?	For config and project files (README, licenses, config), not the main source code.
What is `Cargo.toml`?	The project’s Cargo configuration file.
What file format is `Cargo.toml` written in?	TOML.
What does the `[package]` section in `Cargo.toml` contain?	Package configuration metadata (like name/version/edition).
What does the `[dependencies]` section in `Cargo.toml` list?	The crates (dependencies) your project uses.
In Rust, packages of code are referred to as what?	Crates.
How do you build a Cargo project?	Run `cargo build`.
What does Cargo’s default build produce?	A debug build intended for development.
Where does Cargo store build outputs by default?	In the `target/` directory (debug builds under `target/debug`).
What does `cargo run` do?	Builds (if needed) and then runs the program.
When will `cargo run` rebuild your program?	When the source files have changed since the last build.
What does `cargo check` do?	Checks that code compiles but does not produce an executable.
Why use `cargo check` during development?	It’s usually faster feedback than a full build.
What is `Cargo.lock` for?	It records the exact versions of dependencies used in the project.
Should you edit `Cargo.lock` manually?	No—Cargo manages it.
How do you build with optimizations for release?	Run `cargo build --release`.
What’s the trade-off of `cargo build --release`?	Faster runtime, but slower compile times.
Where do release build outputs go?	Under `target/release`.
When does Cargo provide the biggest advantage over calling `rustc` directly?	As projects grow (multiple files) or when you add dependencies.
How can you convert an existing non-Cargo project to use Cargo?	Move code into `src/` and create a `Cargo.toml` (or run `cargo init`).
What does `loop { ... }` do?	Creates an infinite loop that runs until you exit it (e.g., with `break`).
What does `break` do in a loop?	Exits the nearest enclosing loop immediately.
What does `continue` do in a loop?	Skips the rest of the current loop iteration and starts the next iteration.
What is the Rust prelude?	A set of standard-library items automatically in scope in every program.
When do you write a `use ...;` statement?	To bring a module/type/trait into scope when it isn’t already available (e.g., not in the prelude) or to shorten paths.
What does `::` mean in Rust paths?	It separates path segments (modules/types/traits) and is used to access associated items (e.g., `Type::function`).
What is an associated function?	A function defined on a type and called with `Type::function`, not on an instance.
Are variables mutable by default?	No; bindings are immutable by default.
What does `mut` mean on a binding?	It allows reassignment of the binding and/or mutation through it (when the type supports mutation).
What is `String` (std) in one phrase?	A growable, UTF-8–encoded owned string.
What does `&T` mean?	A shared (immutable) reference to a value of type `T`.
What does `&mut T` mean?	A mutable reference to a value of type `T` (allows mutation through the reference).
Why pass `&mut T` to a function?	So the function can mutate a caller-owned value without taking ownership of it.
What is `std::io::stdin()` conceptually?	A handle to standard input that you can read user input from.
What does `read_line(&mut String)` return?	A `Result` indicating success (`Ok(...)`) or failure (`Err(...)`).
What does `read_line` do to the string buffer?	It appends the input line (including the trailing newline) to the `String`.
What is method chaining?	Calling methods on returned values in sequence, like `a().b().c()`.
What is `Result<T, E>`?	An enum that represents either success (`Ok(T)`) or failure (`Err(E)`).
What are the `Result` variants?	`Ok` and `Err`.
What does `expect("msg")` do on a `Result`?	If `Ok`, unwraps the value; if `Err`, panics and prints the provided message.
What is `match` used for?	Branching on patterns (often enum variants) in an exhaustive way and producing a value.
What does the wildcard pattern `_` mean?	Match anything (catch-all), ignoring the matched value.
What does `trim()` do (Rust strings)?	Removes leading and trailing whitespace (including `\n` / `\r\n`).
What does `parse::<T>()` do?	Attempts to convert a string to type `T`, returning a `Result`.
Why does `parse` return a `Result`?	Because the conversion can fail for invalid input.
Why add a type annotation like `: u32`?	To guide type inference and choose the concrete type you want.
What is shadowing?	Re-declaring a name to bind it to a new value (possibly a different type) in the same scope.
What does “static typing” mean?	Types are checked at compile time, and many mismatches are rejected before the program runs.
Why can’t you compare values of different types directly?	Operations like comparison require compatible types; Rust forces explicit conversions instead of implicit type mixing.
What is `std::cmp::Ordering` for?	Representing comparison outcomes: `Less`, `Greater`, or `Equal`.
What does `cmp(&other)` return?	An `Ordering` describing how two values compare.
Difference between `start..end` and `start..=end`?	`start..end` excludes `end`; `start..=end` includes `end`.
What does `{name}` do in `println!`?	Inserts the value of the named variable into the output.
Is `match` an expression or a statement?	An expression: it evaluates to a value, so you can write `let x = match ...;`.
What does a `match` arm consist of?	A pattern to match and an expression/block to run when it matches.
What does a pattern like `Ok(num)` do in a `match`?	It matches the `Ok` variant and binds the inner value to `num`.
Why must `match` be exhaustive?	Rust requires handling all possible cases (or using `_`) so you don’t miss a variant.
What is “turbofish” syntax `::<T>` used for?	To specify generic type parameters explicitly, e.g., `parse::<u32>()`.
Why bring a trait into scope with `use`?	To make the trait’s methods available for method-call syntax on compatible types.
What does Rust error `E0384` indicate?	You attempted to assign to an immutable binding (e.g., “cannot assign twice to immutable variable”).
When does Rust catch attempts to reassign an immutable binding?	At compile time (a compile-time error).
Why does Rust default to immutable bindings?	It nudges you toward safer, easier-to-reason-about code and supports safe concurrency.
What kind of bug can immutability help prevent?	Code that assumes a value won’t change being broken by code that changes it (especially intermittently).
What does adding `mut` to a binding communicate?	Intent: the value bound to this name is expected to change.
What keyword declares a constant in Rust?	`const`
Can you use `mut` with a `const`?	No—constants are always immutable.
What must a Rust `const` declaration always include?	A type annotation (e.g., `const X: u32 = ...;`).
Where can Rust constants be declared?	In any scope, including global scope.
What can Rust constants be initialized with?	Only constant expressions (values computable at compile time).
What is the “constant expression” restriction for constants?	A `const` can’t depend on values only known at runtime.
How long is a Rust constant valid?	For the entire time the program runs, within the scope it’s declared.
Rust constant naming convention?	ALL_CAPS with underscores between words.
Why replace repeated “magic numbers” with a `const`?	Conveys meaning; one place to update if the value changes.
What is shadowing in Rust (in one phrase)?	Rebinding the same name with `let`, creating a new binding that hides the previous one.
How do you shadow a variable?	Write `let name = ...;` again with the same name.
Shadowing vs `mut`: what’s the key difference in how the value changes?	Shadowing creates a new binding (requires `let`); `mut` allows reassignment of the same binding.
Shadowing: why does it help prevent accidental reassignment?	Changing the value requires `let`; an assignment without `let` won’t compile for an immutable binding.
Shadowing vs `mut`: can shadowing change the type?	Yes; shadowing can change the type while reusing the same name.
Why can’t `mut` be used to “change” a variable’s type?	A binding’s type is fixed; assignment requires a value of the same type.
How does shadowing interact with inner scopes?	An inner block can shadow a name temporarily; when the block ends, the outer binding is visible again.
Why might you choose shadowing over new variable names?	It avoids awkward names (e.g., `spaces_str`/`spaces_num`) while keeping code readable.
What does the compiler often suggest for an immutability assignment error?	Make the binding mutable (e.g., change `let x = ...` to `let mut x = ...`).
If you want a transformed value but still prefer immutability, what Rust feature helps?	Shadowing: rebind with `let` to apply transformations, then keep the new binding immutable.
What two subsets of data types does TRPL highlight?	Scalar types and compound types.
What is a scalar type (Rust)?	A type that represents a single value; Rust’s primary scalar types are integers, floats, booleans, and chars.
What is a compound type (Rust)?	A type that groups multiple values into one; Rust’s primitive compound types are tuples and arrays.
Integer types: what do `i*` vs `u*` mean (Rust)?	`i*` is signed (can be negative); `u*` is unsigned (nonnegative).
What does a type like `u32` indicate?	An unsigned 32-bit integer.
What built-in integer sizes does Rust provide?	8/16/32/64/128-bit signed+unsigned plus `isize`/`usize`.
What determines the size of `isize`/`usize`?	The target architecture (64-bit on 64-bit platforms; 32-bit on 32-bit platforms).
What integer type does Rust default to when unspecified?	`i32`.
When is `usize` commonly used in Rust?	For indexing collections/arrays and sizes/lengths.
How can you write integer literals in hex/octal/binary (Rust)?	Hex `0x...`; octal `0o...`; binary `0b...`; decimal is the default.
What is a numeric type suffix on a literal?	A suffix like `57u8` that explicitly selects the literal’s type.
What does `_` do in numeric literals (Rust)?	It’s a visual separator only (e.g., `1_000` equals `1000`).
What is integer overflow (Rust)?	When a value exceeds the range a fixed-size integer type can represent.
What happens on integer overflow in debug builds (Rust)?	Runtime overflow checks cause a panic when overflow occurs.
What happens on integer overflow in release builds by default (Rust)?	It wraps using two’s complement wrapping (no overflow panic by default).
What are the four method families for handling overflow explicitly?	`wrapping_*`; `checked_*`; `overflowing_*`; `saturating_*`.
What do `wrapping_*` methods do?	Always wrap on overflow (in all build modes).
What do `checked_*` methods do on overflow?	Return `None` (an `Option` indicating overflow).
What do `overflowing_*` methods return?	The wrapped value and a boolean indicating whether overflow happened.
What do `saturating_*` methods do?	Clamp results at the type’s min/max instead of wrapping.
What floating-point types does Rust have?	`f32` and `f64`.
What floating-point type does Rust default to?	`f64`.
How does integer division behave in Rust?	It truncates toward zero.
What is the boolean type called in Rust?	`bool` (values `true` and `false`).
How do you write a `char` literal vs a string literal (Rust)?	`char` uses single quotes (e.g., `'z'`); strings use double quotes (e.g., "z").
What does `char` represent in Rust (and size)?	A Unicode scalar value; `char` is 4 bytes.
What is a tuple (Rust)?	A fixed-length compound type that can hold values of different types.
What does a tuple type annotation look like?	`(T1, T2, T3)`.
How do you destructure a tuple (Rust)?	Use a pattern: `let (x, y, z) = tup;`.
How do you access tuple elements by index (Rust)?	Use dot-indexing: `tup.0`, `tup.1`, etc.
What is the unit type/value in Rust?	`()`; an empty value / empty return type.
What is an array in Rust (core properties)?	A fixed-length collection where every element has the same type.
What is Rust array type syntax (including repeat init)?	`[T; N]` and repeat init like `[value; N]`.
Arrays vs vectors: when should you prefer `Vec<T>` over arrays?	When you need a growable/shrinkable collection; if unsure, use a vector.
What happens on out-of-bounds array indexing in Rust (and why)?	It panics at runtime via bounds checks to prevent invalid memory access (memory safety).
What is Rust’s naming convention for functions and variables?	snake_case: all lowercase with underscores between words.
What is the syntax for calling a function in Rust?	Write the function name followed by parentheses, e.g., `do_thing()`.
Does Rust care whether a function is defined before or after it’s called?	No; order in the file doesn’t matter as long as the function is in scope for the caller.
What must be true for code to call a function in Rust?	The function must be defined in a scope visible to the caller.
What is the difference between a parameter and an argument?	A parameter is a named variable in the function signature; an argument is the concrete value passed at the call site.
In Rust function signatures, what must you write for each parameter?	The parameter’s type.
What is the syntax for a typed parameter in Rust?	`name: Type`.
How do you write multiple parameters in a Rust function signature?	Comma-separated, e.g., `fn f(a: i32, b: char)`.
Why does Rust require parameter types in function signatures?	It helps the compiler produce better errors and reduces the need for type annotations elsewhere.
What is a statement (Rust, concept)?	An instruction that performs an action and does not return a value.
What is an expression (Rust, concept)?	Something that evaluates to a value.
Is `let x = 5;` a statement or an expression in Rust?	A statement.
Why can’t you write `let x = (let y = 6);` in Rust?	`let` is a statement and doesn’t produce a value to assign.
Are function definitions statements or expressions in Rust?	Statements.
Is calling a function a statement or an expression in Rust?	An expression (it evaluates to a value).
Is calling a macro (e.g., `println!`) a statement or an expression in Rust?	An expression.
Is a block `{ ... }` an expression in Rust?	Yes; a block can evaluate to a value.
In a block expression, what determines the block’s value?	The value of its final expression (the “tail expression”).
What is a “tail expression” in Rust?	The final expression in a block without a trailing semicolon; it becomes the block’s value.
What does adding a semicolon to an expression do in Rust?	It turns the expression into a statement, so it no longer yields its value.
In a block, what happens if the last line ends with `;`?	The block’s value becomes `()` (unit), because there is no tail expression.
How do you declare a function return type in Rust?	With `-> T` after the parameter list.
What is the default return type when a Rust function omits `-> ...`?	`()` (unit).
How do Rust functions typically return a value without `return`?	By making the last line of the body a tail expression (no semicolon).
What does the `return` keyword do in Rust?	Returns early from a function with the provided value.
What common mistake causes a function to return `()` unexpectedly?	Putting a semicolon after the intended return expression (removing the tail expression).
What does `()` represent as a return value?	The unit value (an “empty” value).
Why does `x + 1;` often cause a return-type mismatch in Rust functions?	The semicolon makes it a statement, so it yields `()` instead of the numeric value.
What kind of compiler error often appears when a function’s body yields `()` but the signature says it returns a non-`()` type?	A “mismatched types” error (expected the declared return type, found `()`).
How can a block expression be used with `let`?	You can bind a block’s value: `let x = { ... tail_expression ... };`.
Why do programmers write comments?	To add extra explanation for humans when code needs clarification.
Do Rust comments affect compilation or program behavior?	No; the compiler ignores comments.
What is the idiomatic single-line comment syntax in Rust?	Start with `//` (comment continues to the end of the line).
How do you write a multi-line comment using `//` in Rust?	Use `//` at the start of each line.
Where can `//` comments be placed in Rust code?	On their own line above code or at the end of a line containing code.
Which comment placement is more commonly seen in Rust style: end-of-line or above-line?	More often on a separate line above the code it annotates.
What does “the comment continues until the end of the line” mean?	Everything after `//` on that line is treated as comment text.
Besides `//` comments, what other kind of comment does Rust have?	Documentation comments (covered later in TRPL, e.g., publishing a crate).
What are the two main control-flow capabilities highlighted in this section?	Branching on conditions and repeating code (looping).
What is an `if` expression used for (Rust)?	Branching: run a block when a condition is true; optionally run an `else` block when false.
What type must a Rust `if` condition have?	`bool`.
Does Rust perform truthy/falsy coercions for `if` conditions?	No; conditions must be explicitly boolean.
What happens if an `if` condition is false and there is no `else`?	The `if` block is skipped and execution continues.
What is `else if` used for?	Checking multiple conditions in sequence.
In an `if`/`else if` chain, how many branches run?	At most one: the first branch whose condition is true.
Why can “too many `else if`” be a code smell (per TRPL)?	It can clutter code; consider refactoring (e.g., using `match` for complex branching).
What are the blocks in an `if` expression sometimes called?	Arms (similar terminology to `match`).
Is `if` a statement or an expression in Rust?	An expression (it can produce a value).
What does “`if` is an expression” enable in Rust?	Using `if` on the right-hand side of `let` to choose a value.
When using `if` in `let`, what must be true about the result types of each arm?	All possible arm results must have the same type.
Why must those arm result types match (Rust)?	A variable has a single compile-time type; Rust must know it definitively.
What common compile error happens when `if` and `else` produce different types?	An error that the `if` and `else` have incompatible types (type mismatch).
What are the three kinds of loops in Rust?	`loop`, `while`, and `for`.
What is one practical use-case for an infinite-style loop besides “repeat forever”?	Retrying an operation until it succeeds / a condition is met.
How can a `loop` produce a value (Rust)?	Use `break <expr>`; the loop expression evaluates to that value.
Where does the value from `break <expr>` go?	It becomes the value of the entire `loop` expression (often bound with `let result = loop { ... };`).
What is the difference between `break` and `return` in this context?	`break` exits the current loop; `return` exits the current function.
In nested loops, which loop do `break` and `continue` affect by default?	The innermost loop at that point.
What is a loop label used for?	Disambiguating which loop `break`/`continue` should apply to in nested loops.
What is the syntax shape of a labeled loop?	`'label: loop { ... }` (label starts with a single quote).
How do you break an outer labeled loop from inside an inner loop?	`break 'label;`.
What does a `while` loop represent (Rust)?	“Run while condition is true; stop when it becomes false.”
Why does `while` reduce nesting versus `loop` + `if` + `break` patterns?	The condition is built into the loop construct, so it’s clearer and less nested.
What is a common use of `while` shown in TRPL?	Counting down until a condition (e.g., `number != 0`) becomes false.
What is a `for` loop primarily used for (Rust)?	Iterating over items in a collection/iterator.
Why is iterating with `while` + manual index considered error-prone?	Off-by-one mistakes can cause panics (out-of-bounds) or skipped elements.
Why can `while` + manual indexing also be slower?	It can require repeated bounds checks / comparisons each iteration.
Why is `for` preferred when iterating a collection (TRPL’s emphasis)?	Safer, more concise, and often more efficient.
What advantage does `for` have when the collection length changes?	You don’t need to update an index bound; it iterates the elements directly.
What does TRPL recommend as the most commonly used loop construct in Rust?	`for`.
What standard-library concept is used to run a loop a fixed number of times?	A range (an iterator producing a sequence of numbers).
What does calling `.rev()` on an iterator do (conceptually)?	Reverses the iteration order.
Why might you wrap a range in parentheses before calling `.rev()`?	To call the method on the range expression as a whole, e.g., `(1..4).rev()`.
What is ownership (Rust)?	A set of rules that govern how a Rust program manages memory.
How does Rust enforce ownership rules?	With compile-time checks; code that violates the rules won’t compile.
Do ownership checks add runtime overhead (Rust)?	No; the checks happen at compile time.
What is the stack (memory) organized as?	Last in, first out (LIFO).
What are “push” and “pop” (stack)?	Push adds data to the top; pop removes data from the top.
What must be true of data stored on the stack?	It must have a known, fixed size at compile time.
When must data be stored on the heap?	When its size is unknown at compile time or may change.
What happens when you allocate on the heap?	The allocator finds space, marks it used, and returns a pointer (address).
Why is pushing to the stack usually faster than heap allocation?	The stack top is always available; heap allocation requires searching/bookkeeping.
Why is accessing heap data usually slower than stack data?	You must follow a pointer; data may be less cache-local.
What happens to values/local variables on a function call (conceptually)?	Arguments and locals are pushed onto the stack; they’re popped when the function returns.
What are Rust’s three ownership rules?	Each value has an owner; only one owner at a time; when the owner goes out of scope, the value is dropped.
What is “scope” (Rust) in one phrase?	The range of code where a binding is valid.
When is a binding valid (scope-wise) in Rust?	From its declaration until the end of the current scope.
Why aren’t string literals suitable for all text (Rust)?	They’re immutable, and not all text is known at compile time.
What does `String` enable compared to string literals (Rust)?	Owned, heap-allocated, growable text for runtime-sized content.
How do you create a `String` from a literal (Rust)?	`String::from("hello")`.
Why can a `String` be mutated but a string literal can’t (Rust)?	`String` owns heap-allocated data; literals are immutable data baked into the binary.
What must happen at runtime to build a `String`?	It must allocate heap memory for its contents.
When is a `String`’s heap memory freed (Rust)?	When its owner goes out of scope and Rust runs `drop`.
What does `drop` do (Rust, conceptually)?	Runs cleanup for a value going out of scope (e.g., freeing heap memory).
What happens when you assign a `String` to another variable (Rust ownership)?	The value moves: stack metadata is copied, heap data is not; the source binding becomes invalid.
Why does Rust invalidate the source binding after a move?	To prevent double frees and other use-after-free style bugs.
Does Rust automatically deep-copy heap data on assignment?	No; implicit copies are intended to be inexpensive.
How do you deep-copy a `String` (Rust)?	Call `clone()` to copy the heap data (potentially expensive).
What is stored in a `String` value on the stack (Rust)?	A pointer to the heap data plus length and capacity.
What does the `Copy` trait mean for assignment/passing (Rust)?	The value is trivially copied; the original remains valid.
Why can’t a type be `Copy` if it (or a field) implements `Drop`?	`Drop` implies special cleanup; `Copy` would allow duplicated values that both get dropped.
Which types commonly implement `Copy` (Rust)?	Integers; `bool`; floats; `char`; tuples of only `Copy` types (e.g., `(i32, i32)`).
How does passing a value to a function affect ownership (Rust)?	It moves or copies, just like assignment does.
What happens when a function takes a `String` parameter by value?	Ownership moves into the function; the caller can’t use it afterward.
What happens to ownership when a function returns a value?	The returned value moves to the caller.
Why return a tuple like `(String, usize)` from a function (Rust)?	To return ownership of the input value along with computed data (e.g., length).
What is a reference (Rust)?	An address you can follow to access data owned by another variable, without taking ownership.
What does “borrowing” mean (Rust)?	Creating a reference to use a value without taking ownership of it.
What does applying `&` to a value do (Rust)?	Creates a shared (immutable) reference to that value (borrows it).
Why pass a reference to a function instead of an owned value (Rust)?	So the function can use the value without moving ownership; the caller can still use it afterward.
Why don’t you need to “return ownership back” when a function takes references (Rust)?	Because references don’t take ownership in the first place.
How are Rust references like pointers, and how are they different?	Like pointers, they are addresses; unlike raw pointers, references are guaranteed valid for their lifetime.
What is dereferencing (Rust)?	Accessing the value a reference points to (often using the dereference operator `*`).
What is the dereference operator in Rust?	`*` (used to dereference a reference).
Why doesn’t the referenced value get dropped when a reference goes out of scope (Rust)?	Because the reference doesn’t own the value; only the owner is dropped.
Can you mutate through a shared reference `&T` (Rust)?	No; shared references are immutable by default, so mutation through `&T` is rejected.
How do you allow a function to mutate a borrowed `String` (Rust)?	Take a mutable reference parameter, e.g. `fn f(s: &mut String) { ... }`.
What must be true to create `&mut s` (Rust)?	The binding must be mutable (e.g., `let mut s = ...;`).
What does a mutable reference communicate at the call site (Rust)?	That the function is allowed to mutate the borrowed value (`&mut` makes mutation explicit).
Core rule: how many mutable references can you have at once (Rust)?	At most one mutable reference to a value at a time.
Core rule: how many immutable references can you have at once (Rust)?	Any number of immutable references, as long as there’s no mutable reference in use.
Core rule: can you mix mutable and immutable references at the same time (Rust)?	No: you can’t have `&mut` while immutable borrows of the same value are still in use.
Why does Rust forbid multiple mutable references at the same time?	To prevent data races by ensuring controlled, exclusive mutation.
What is a data race (Rust explanation)?	When 2+ pointers access the same data at once, at least one writes, and there’s no synchronization.
How does Rust prevent data races related to references?	By enforcing borrowing rules at compile time (exclusive mutable access or shared read-only access).
How can you get two mutable references to the same value without overlap (Rust)?	Use scopes so the first mutable borrow ends before the second begins (e.g., an inner block).
When does a reference’s “active borrow scope” last (Rust)?	From creation through the last time the reference is used (not necessarily the end of the enclosing block).
Why can a mutable borrow be allowed after immutable borrows in the same scope (Rust)?	If the immutable borrows are no longer used, their borrow scopes have ended before the mutable borrow starts.
What’s a common symptom of trying to mutate through `&String`?	A compile error indicating you can’t borrow as mutable behind a `&` reference; use `&mut` instead.
How would you write a non-owning length function for a `String` (Rust)?	`fn len(s: &String) -> usize { s.len() }` (borrows; doesn’t move).
What is a dangling reference (general concept)?	A reference to memory that has been freed or is no longer valid.
What guarantee does Rust provide about references and dangling pointers?	References will never be dangling; the compiler enforces validity.
Why can’t a function return a reference to a local variable (Rust)?	The local is dropped when the function ends, so the returned reference would dangle.
What’s the typical fix for “returning a reference to a local” (Rust)?	Return an owned value instead (e.g., return `String`, not `&String`).
Why can returning `&String` from a function trigger “missing lifetime specifier” (high level)?	The return type is borrowed, but there’s no valid source value that outlives the function to borrow from.
What does “references must always be valid” mean (Rust rule)?	A reference can’t outlive the data it points to.
Rules recap: references (Rust)	Either 1 mutable reference or many immutable references; references must always be valid.
Why are borrow-checker errors useful even if frustrating (Rust)?	They catch potential bugs at compile time and point to where the problematic borrows occur.
What is a slice in Rust?	A reference to a contiguous sequence of elements in a collection (it does not own the data).
Why can returning a `usize` index into a `String` be brittle (Rust)?	The number is only meaningful for that specific string state; the string can change and the index becomes invalid.
What problem do string slices solve compared to returning indices (Rust)?	They tie the “substring” result to the underlying data via borrowing, so invalid states are rejected by the compiler.
What is a string slice type in Rust?	`&str`.
How do you create a string slice from a `String` (Rust)?	With range syntax: `&s[start..end]` (e.g., `&s[..2]`, `&s[3..]`, `&s[..]`).
In Rust slice ranges like `a..b`, is `b` inclusive or exclusive?	Exclusive: `a..b` includes `a` up to but not including `b`.
What does `&s[..]` mean for a `String` in Rust?	A slice of the entire string.
What does omitting the start in a slice range mean (Rust)?	Start at index 0 (e.g., `&s[..n]`).
What does omitting the end in a slice range mean (Rust)?	Go to the end (e.g., `&s[n..]`).
What does a string slice store internally (high level)?	A pointer into the string data plus a length.
What constraint applies to string-slice indices in Rust (`&s[a..b]`)?	They must be at valid UTF-8 character boundaries; slicing in the middle of a multibyte char will panic.
Why is `fn f(s: &str)` more flexible than `fn f(s: &String)` (Rust)?	`&str` works with both string literals and `String` values (via deref coercions / slicing).
What is the type of a string literal in Rust (e.g., `"Hello"`)?	`&'static str` (a string slice pointing into the binary).
Why are Rust string literals immutable?	They are `&str` slices pointing to read-only data baked into the binary.
How can you iterate over a `String` as bytes (Rust)?	Use `s.as_bytes()` to get a `&[u8]`.
What does `enumerate()` add to an iterator (Rust)?	It yields `(index, item)` pairs.
In `for (i, &b) in bytes.iter().enumerate()`, why use `&b` in the pattern (Rust)?	Because `iter()` yields `&u8`, and `&b` destructures/dereferences the reference to get the `u8` value.
What is `b' '` in Rust?	A byte literal (here: the ASCII space byte).
Why does Rust reject mutating a `String` while a slice into it is still used?	Borrowing rules: you can’t take a mutable borrow if an immutable borrow is still active and later used.
What is an array/slice slice type in Rust (general case)?	`&[T]` (e.g., slicing an array gives `&[i32]`).
How do you take a slice of an array in Rust?	With range syntax: `&a[start..end]` (e.g., `let s = &a[1..3];`).
What is a struct in Rust?	A custom data type that groups related values into named fields.
Why use a struct instead of a tuple (Rust)?	Fields are named, so meaning doesn’t depend on position and code is clearer/flexible.
How do you define a struct type in Rust?	With `struct Name { field: Type, ... }`.
What are the pieces inside a struct definition called (Rust)?	Fields (each has a name and a type).
How do you create a struct instance in Rust?	`Name { field1: value1, field2: value2, ... }`.
Do you have to list struct fields in declaration order when instantiating (Rust)?	No; you can specify fields in any order.
How do you access a field on a struct instance (Rust)?	Dot notation, e.g. `user.email`.
To mutate a struct field, what must be true about the binding (Rust)?	The entire instance binding must be mutable (e.g., `let mut user = ...;`).
Can you make only one field mutable in an otherwise immutable struct value (Rust)?	No; Rust requires the whole instance to be mutable to mutate any field.
What is the field init shorthand in Rust?	When a variable name matches a field name, you can write `field` instead of `field: field`.
What does struct update syntax `..other` do (Rust)?	Fills in unspecified fields from another instance of the same struct type.
Where must `..other` appear in a struct literal (Rust)?	Last, after any explicitly set fields.
Why can struct update syntax make the original instance unusable (Rust)?	It moves non-`Copy` fields (like `String`) from the source into the new value.
When does struct update syntax copy instead of move fields (Rust)?	When the field type implements `Copy` (e.g., `bool`, integers).
What is a tuple struct in Rust?	A struct type with unnamed fields, declared like `struct Name(T1, T2, ...)`.
Why use a tuple struct (Rust)?	To give a tuple-like value a distinct type name without naming each field.
How do you access a tuple struct field (Rust)?	With positional dot syntax like `.0`, `.1`, etc.
How do you destructure a tuple struct (Rust)?	Use the type name in the pattern, e.g. `let Point(x, y, z) = origin;`.
What is a unit-like struct in Rust?	A struct with no fields, declared like `struct Name;`.
How do you instantiate a unit-like struct (Rust)?	Use the name as a value, e.g. `let x = Name;`.
Why might you use a unit-like struct (Rust)?	To implement a trait on a type that carries no data.
Why might a struct store `String` instead of `&str` (Rust)?	To own its data so it stays valid as long as the struct value exists.
What’s required to store references in a struct (Rust)?	Lifetime parameters on the struct and reference fields (e.g., `struct User<'a> { name: &'a str }`).
What compile error do you get if a struct has `&str` fields with no lifetimes (Rust)?	“missing lifetime specifier”.
Why group related values into a single struct parameter instead of separate parameters (Rust)?	It makes the relationship explicit, improves readability, and reduces mixups by passing one named bundle.
What’s a key drawback of using a tuple as a “record” (Rust)?	Tuple fields are unnamed, so you must use positional access like `.0`/`.1`, which is less self-documenting.
How do you pass a struct to a function without transferring ownership (Rust)?	Take `&Type` in the signature and pass `&value` at the call site.
Why prefer borrowing a struct argument instead of taking ownership (Rust)?	The caller keeps using the value; avoids unnecessary moves/clones.
Can you move a non-`Copy` field out of `&Struct` (Rust)?	No; you can only borrow fields through a shared reference (moving out would be invalid).
In `println!`, what does `{}` require from the value’s type (Rust)?	An implementation of `std::fmt::Display`.
What is `std::fmt::Display` intended for (Rust)?	User-facing, “pretty” output.
What is `std::fmt::Debug` intended for (Rust)?	Developer/debugging output (inspect internal state).
How do you print a value using Debug formatting in `println!` (Rust)?	Use `{:?}`, e.g. ``println!("{value:?}")``.
How do you pretty-print Debug output in `println!` (Rust)?	Use `{:#?}`, e.g. ``println!("{value:#?}")``.
How do you add a default Debug implementation for a struct (Rust)?	Add `#[derive(Debug)]` above the struct definition.
What does `dbg!(expr)` do (Rust)?	Prints file/line + the expression and its value (using `Debug`), and returns the expression’s value.
Does `dbg!` print to stdout or stderr (Rust)?	Stderr.
Why can `dbg!(value)` affect ownership (Rust)?	`dbg!` takes ownership of the expression result (so it can move non-`Copy` values).
How do you use `dbg!` without moving a value (Rust)?	Debug-print a reference: `dbg!(&value)`.
How do you attach behavior like `area` to a struct as a method (Rust)?	Use an `impl` block, e.g. ``impl Rectangle { fn area(&self) -> u32 { ... } }``.
What distinguishes a method from a free function (Rust)?	A method is defined in a type context (e.g., `impl`) and has a `self` receiver as its first parameter.
Where do you define methods for a struct (Rust)?	Inside an `impl Type { ... }` block.
What does the `self` parameter represent in a method (Rust)?	The instance the method is called on (the receiver).
How do you call a method on a value (Rust)?	Use dot syntax: `value.method(args...)`.
What is `&self` shorthand for in a method signature (Rust)?	`self: &Self`.
What does `Self` mean inside an `impl Type` block (Rust)?	An alias for the type being implemented (`Type`).
What are the three common receiver forms for methods (Rust)?	`&self` (borrow immutably); `&mut self` (borrow mutably); `self` (take ownership).
Why is `&self` a common choice for many methods (Rust)?	It lets the method read data without taking ownership or mutating the receiver.
When is a method with receiver `self` (takes ownership) typically used (Rust)?	When the method consumes/transforms the value and you want to prevent use of the original afterward.
Why use methods instead of free functions (Rust, high level)?	Organization (capabilities live with the type) and ergonomic calls (no need to repeat the receiver type in every signature).
Can methods take additional parameters besides `self` (Rust)?	Yes; parameters after `self` work like normal function parameters.
How can a struct have a method with the same name as a field (Rust)?	Use `value.field` for the field and `value.field()` for the method.
What is a “getter” method pattern (Rust)?	A method (often `&self`) that returns a field value, enabling controlled read-only access.
Does Rust auto-generate getters for struct fields?	No; you write them yourself if you want that API.
Why doesn’t Rust need a `->` operator for method calls?	Method calls use dot syntax plus automatic referencing/dereferencing for the receiver.
What is “automatic referencing/dereferencing” in Rust method calls?	The compiler inserts `&`, `&mut`, or `*` so the receiver matches the method’s `self` type.
What does a `can_hold(&self, other: &Rectangle) -> bool`-style method usually check (Rust)?	That `self`’s dimensions are greater than `other`’s (e.g., `self.width > other.width && self.height > other.height`).
How do you define and call a constructor-like associated function (Rust)?	Define a function without `self` in an `impl` returning `Self` (often named `new`, but not special) and call it as `Type::function(...)` (e.g., `fn square(size: u32) -> Self { Self { ... } }`).
