What is rustup?	A command-line tool for managing Rust versions and associated tools.
Besides the compiler, what system tool is needed to produce a final executable?	A linker.
How do you update Rust installed via rustup?	Run `rustup update`.
How do you uninstall Rust and rustup?	Run `rustup self uninstall`.
How do you open the locally installed Rust documentation?	Run `rustup doc`.
After caching dependencies, how do you run Cargo commands without network access?	Use the `--offline` flag.
What file extension do Rust source files use?	`.rs`
What is the convention for multi-word Rust filenames?	Use underscores (e.g., `hello_world.rs`).
What is special about the `main` function in an executable Rust program?	It is the first code that runs.
In `fn main() {}`, what does `fn` declare?	A function.
How are function bodies written in Rust?	Inside curly braces `{}` (required for function bodies).
What does `println!` do in the Hello World example?	Prints the provided text to the screen/terminal.
What does the `!` in `println!` indicate?	It’s a macro invocation, not a normal function call.
What does a semicolon `;` typically indicate at the end of a line in Rust?	The expression/statement is finished.
How do you compile `main.rs` from the command line?	Run `rustc main.rs`.
After successful compilation with `rustc`, what do you get to run?	A binary executable.
How do you run the compiled executable on Linux/macOS?	`./main`
How do you run the compiled executable on Windows?	`.\\main`
What does it mean that Rust is ahead-of-time compiled?	You can compile to an executable that can run without Rust installed on the target machine.
Why use Cargo instead of `rustc` directly as projects grow?	To manage options/dependencies and make sharing/building easier.
What is Cargo?	Rust’s build system and package manager.
What kinds of tasks does Cargo handle for you?	Building your code, downloading dependencies, and building those dependencies.
Why do most Rust projects use Cargo?	It automates common project tasks and makes managing dependencies easier.
How can you check whether Cargo is installed?	Run `cargo --version`.
What does `cargo new <name>` do?	Creates a new project directory with a starter Rust program and Cargo config.
What two top-level items does Cargo generate in a new binary project (besides the `src` dir)?	`Cargo.toml` and a `src/` directory (with `main.rs` inside `src/`).
Where does Cargo expect Rust source files to live?	Inside the `src/` directory.
What is the purpose of the top-level project directory in a Cargo project?	For config and project files (README, licenses, config), not the main source code.
What is `Cargo.toml`?	The project’s Cargo configuration file.
What file format is `Cargo.toml` written in?	TOML.
What does the `[package]` section in `Cargo.toml` contain?	Package configuration metadata (like name/version/edition).
What does the `[dependencies]` section in `Cargo.toml` list?	The crates (dependencies) your project uses.
In Rust, packages of code are referred to as what?	Crates.
How do you build a Cargo project?	Run `cargo build`.
What does Cargo’s default build produce?	A debug build intended for development.
Where does Cargo store build outputs by default?	In the `target/` directory (debug builds under `target/debug`).
What does `cargo run` do?	Builds (if needed) and then runs the program.
When will `cargo run` rebuild your program?	When the source files have changed since the last build.
What does `cargo check` do?	Checks that code compiles but does not produce an executable.
Why use `cargo check` during development?	It’s usually faster feedback than a full build.
What is `Cargo.lock` for?	It records the exact versions of dependencies used in the project.
Should you edit `Cargo.lock` manually?	No—Cargo manages it.
How do you build with optimizations for release?	Run `cargo build --release`.
What’s the trade-off of `cargo build --release`?	Faster runtime, but slower compile times.
Where do release build outputs go?	Under `target/release`.
When does Cargo provide the biggest advantage over calling `rustc` directly?	As projects grow (multiple files) or when you add dependencies.
How can you convert an existing non-Cargo project to use Cargo?	Move code into `src/` and create a `Cargo.toml` (or run `cargo init`).
